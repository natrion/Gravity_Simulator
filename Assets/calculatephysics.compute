#pragma kernel CSMain

struct Particle
{
    float3 position;
    float3 velocity;
};

RWStructuredBuffer<Particle> pointsIn;
RWStructuredBuffer<Particle> pointsOut;
RWStructuredBuffer<float4x4> MetrixTransforms;

bool NormalHitsSphere(float3 normal, float3 origin, float3 spherePos, float sphereRadius, out float3 hitPos) {
    float3 L = spherePos - origin;   // Vector from ray origin to sphere center
    float tca = dot(L, normal);      // Projection of L onto the normal (ray)
    float d2 = dot(L, L) - tca * tca; // Perpendicular distance squared

    float r2 = sphereRadius * sphereRadius;
    if (d2 > r2) return false; // No hit, normal misses the sphere

    float thc = sqrt(r2 - d2); // Distance from tca to intersection points
    float t = tca - thc; // Closest intersection point along the normal

    if (t < 0) return false; // Sphere is behind the origin, no hit

    hitPos = origin + normal * t; // Compute the intersection position
    return true;
}


float4x4 CreateTRSMatrix(float3 pos, float4 rot, float3 scale)
{
    // Create Rotation Matrix from Quaternion (rot: float4)
    float xx = rot.x * rot.x;
    float yy = rot.y * rot.y;
    float zz = rot.z * rot.z;
    float xy = rot.x * rot.y;
    float xz = rot.x * rot.z;
    float yz = rot.y * rot.z;
    float wx = rot.w * rot.x;
    float wy = rot.w * rot.y;
    float wz = rot.w * rot.z;

    float4x4 rotationMatrix = float4x4(
        1.0f - 2.0f * (yy + zz), 2.0f * (xy - wz), 2.0f * (xz + wy), 0.0f,
        2.0f * (xy + wz), 1.0f - 2.0f * (xx + zz), 2.0f * (yz - wx), 0.0f,
        2.0f * (xz - wy), 2.0f * (yz + wx), 1.0f - 2.0f * (xx + yy), 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f
        );

    // Create Scaling Matrix
    float4x4 scaleMatrix = float4x4(
        scale.x, 0.0f, 0.0f, 0.0f,
        0.0f, scale.y, 0.0f, 0.0f,
        0.0f, 0.0f, scale.z, 0.0f,
        0.0f, 0.0f, 0.0f, 1.0f
        );

    // Create Translation Matrix
    float4x4 translationMatrix = float4x4(
        1.0f, 0.0f, 0.0f, pos.x,
        0.0f, 1.0f, 0.0f, pos.y,
        0.0f, 0.0f, 1.0f, pos.z,
        0.0f, 0.0f, 0.0f, 1.0f
        );

    // Combine Translation, Rotation, and Scaling Matrices (TRS)
    return mul(translationMatrix, mul(rotationMatrix, scaleMatrix));
}
float frameLenght;
float GStrenght;
float size;
float pointMass;
float bounceForceMul = 1;//bounce force multipleyer
float bindForceMul = 1;//bind force multipleyer
#define MAX_POINTS 20
[numthreads(128,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
    float collisionDis = 0.1;
    if (id.x < pointsIn.Length)//checks if this is still part od the distances
    {
        int colidedPoints[MAX_POINTS]; //array of points that are close to main point
        int colidedPointsLenght = 0;// lenght of colidedPoints

        float3 mainPos = pointsIn[id.x].position;//gets the position that the thred is checking

        Particle changedPoint = pointsIn[id.x];
        
        //going thrue all points to calculate forces
        for (int i = 0; i < pointsIn.Length; i++)
        {
            if (i != id.x)//only doing caculations on diferent points
            {               
                Particle testParticle = pointsIn[i];
                float3 testPos = testParticle.position;//inicializatinf test pos

                //geting values for calculating 
                float3 dirTestPos = normalize(testPos - mainPos);
                float disTestPos = distance(mainPos, testPos);
                //calculating gravity
                float gravityForce = (pointMass / (disTestPos * disTestPos)) * GStrenght;
                changedPoint.velocity += gravityForce * dirTestPos;
            
               //adding points to all points that are clsoe to main point 
                if (size*2 > disTestPos)
                {
                    if (colidedPointsLenght < MAX_POINTS)
                    {
                        colidedPoints[colidedPointsLenght] = i;
                        colidedPointsLenght++;
                    }      
                }
            }
        }

        float samples = 5;
        //goint thrue all points that are close if there are some
        if (colidedPointsLenght != 0)
        {

            for (int i = 0; i < colidedPointsLenght; i++)
            {
                Particle colidedParticle = pointsIn[colidedPoints[i]];
                //sampling multiple positions
                for (int o = 0; o < samples; o++)
                {
                    //geting values for calculating 
                    float3 dis = distance(colidedParticle.position, changedPoint.position);
                    float3 dir = normalize(changedPoint.position - colidedParticle.position);
                    //calculating bounce force
                    float bounceForce = bounceForceMul / pow(dis / (size*0.8), 12);
                    changedPoint.velocity += bounceForce * dir;
                    //calculating bind force
                    float bindForceStrenght = min(1, pow(max(0, 1/(dis - size * 0.8)),2)* bindForceMul); //min(pow(DisRevertedToOne, 1)/ samples,1);
                    changedPoint.velocity = lerp( changedPoint.velocity, colidedParticle.velocity, bindForceStrenght/2);
                    //apling all close forces
                    float3 disTochange = (frameLenght * changedPoint.velocity) / samples;
                    changedPoint.position += disTochange;
                }
            }
        }
        else {
            //caculating velociti for points that are not close together
            float3 disTochange = frameLenght * changedPoint.velocity;
            changedPoint.position += disTochange;
        }
            
        //apling buffers
        MetrixTransforms[id.x] = CreateTRSMatrix(changedPoint.position, float4(0, 0, 0, 1), float3(1, 1, 1) * size);
        pointsOut[id.x] = changedPoint;

    }
}
